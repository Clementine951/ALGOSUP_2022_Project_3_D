# Technical specification


## Context 
Robert Pieckering asked us to create a library that can be used to create, modify, play and listen a sound. The user will also be able to choose whether or not to save the sound.

Our project is available on [Github](https://github.com/Clementine951/ALGOSUP_2022_Project_3_D). You can clone it and test it if you have an IDE (We use [visual studio community](https://visualstudio.microsoft.com/fr/vs/community/)) and [Dotnet](https://dotnet.microsoft.com/en-us/download).


## Team
We have a team of six members, Clémentine Curel, Laura-Lee Hollande, Salahedine Namir, Gaël Le Brun, Guillaume Rivière, Victor Leroy.
To achieve this project, we use [Trello](https://trello.com/invite/b/Dlhygf5L/56e58689f9569317c5e523aa5f6a8c66/algosup2022project3d) as a management tool to describe, check, and see all our tasks.We also create a [Slack server](https://join.slack.com/t/algosupstudents/shared_invite/zt-121i5fkhh-A8xHt0dh7M~HSdQsQ151Cw) to communicate between the members of the team. 

## Technologies and library used
| Name | Use|
|-|-|
|F#|This programming language is an exigence for this project. |
|Visual Studio Code Community|We use VSCode Community for this project because we are going to make UnitTest.|
|UnitTest|We make test in order to check our code|
|Github|All the code is available on GitHub|
|SFML|We use this library to help use for save and play waveforms. |
|Dotnet (dotnet 5.0)| We use dotnet to use F#.|


## Compatibility
| Name | Use|
|-|-|
|MacOS|Our project is compatible with MacOS. There is only the PlaySynth module which is unavailable for MacOs.|
|Windows| Our project is compatible with Windows. All modules are available on Windows.|



## Technical

### Generate Wave

#### Wavegen
This module is here in order to create a wave who will be related to a sound later.

        ``` let calcSin sampleRate time freq amp= ``` 
        
   - sampleRate *(Float)* correspond to the sample rate you want for your sound to be
    - time *(Float)* correspond to the duration the wave will last
    - freq *(Float)* relate to the frequency of the sound generated by the wave
    - amp *(Float)* is the amplitude of the wave (from 0 = silence to 1 = max sound)
        
    ```
        let calcSin sampleRate time freq amp=
            let t = 1. + (1./sampleRate) 
            let N = sampleRate * time 
            let omega = 2. * System.Math.PI * freq 


            let points = [(0.)..t..N] 
            let points = points |> List.map(fun x -> amp * sin(omega*x) ) 
            points
    ```
    
There is the full function to make Sine wave. Triangle, Sawtooth and Square have the same architecture, only the formula is different.
    - t is equal to determine the interval betwwen 2 X axis points based on sample rate
    - N is the numbers of points we need based on the time we need to play the note and the sample rate
    - omega is a part of the calculation that is a common on multiple formula
    - points is first the list of X axis points with an increment of t (See above for t)
    - Then the formula is applied to all the list to convert X axis value to convert to Y axis value that now will be a Wave

This explaination works the same for each waves forms.      
The functions available to generate wave are :

      ```let calcSin sampleRate time freq amp=``` 
generate a Sine wave
      ```let calcSquare sampleRate time freq amp =``` 
generate a Square wave
      ```let calcTri sampleRate time freq amp =``` 
generate a Triangle wave
      ```let calcSaw sampleRate time freq amp =``` 
generate a Sawtooth wave


#### NoteToHz

NoteToHz module is composed of 3 main parts, 
    - First the part to convert Note and Octave to a specific Hz
    - Second, Since we have Tuple in the third part, we have a way to acess tuples specific part
    - Third and last, a way to convert a list of notes to a list of float making a list of waves


  ```
    let inputNote = [|
         // ( "NOTE":string, OCTAVE:float, AMPLITUDE:float PLAYTIME:float,)
         ("G", 3., 0.9, 0.9)
         ("G#", 3., 0.9, 0.9)
         ("G", 3., 0.9, 0.9)
     |]
  ```
  Here is an example of the format of how to input notes:
  First part of the Tuple is the note as a String
  Second is the Octave as a Float
  Third is the amplitude of the note
  Fourth is the lenght of the note as Float in seconds

  ##### Convert
  ```let convert note octave = ```
  
  Firstly, Function Convert is made to convert a note and an Octave to the frequency in hertz corresponding to it.

  Available notes are : C, D, E, F, G, A, B and C#, D#, F#, G#, A#

  They are first matched with they own frequency without appliing the octave
  If the note doesn't correspond to a real note, it's considered as 0, it's also used to do silence
  ``` 
    let noteHz =
            match note with
            | "C" | "c" -> 16.35
            | "C#" | "c#" -> 17.32
            | "D" | "d" -> 18.35
            | "D#" | "d#" -> 19.45
            | "E" | "e" -> 20.60
            | "F" | "f" -> 21.83
            | "F#" | "f#" -> 23.12
            | "G" | "g" -> 24.5
            | "G#" | "g#" -> 25.96
            | "A" | "a" -> 27.5
            | "A#" | "a#" -> 29.14
            | "B" | "b" -> 30.87
            | _ -> 0.
  ```

  Then it's multiplied by the octave set in the function.
  Instead of using a recursive to multiply it X time (Octave) by 2, we multiply it by 2^Octave
  Wich does exactly the same.
  ``` 
    let result = noteHz * (2. ** octave) 
    let result = float (Math.Round result)
  ```

  We have face an issue with the result, if it's not rounded it can be result like 1396.4, and produce a wave sound higher than we should have, rounding it fix the problem but loose a small prescision.

  ##### Tuple accessing

  ```
    let first (a, _, _, _) = a
    let second (_, b, _, _) = b
    let third (_, _, c, _) = c
    let fourth (_, _, _, d) = d
  ```
  Since we have a list of tuple who are notes, we need to access each part of the tuple individually.

  ##### noteListToFloatList

  ```
    let noteListToFloatList (inputNote:(string * float * float * float)[]) (sampleRate:float) =
          let listNormalWave = [
              for i = 0 to inputNote.Length-1 do
                  let tmp = 
                      WaveGen.calcSin sampleRate 
                          (fourth inputNote.[i]) 
                          (convert (first inputNote.[i]) (second inputNote.[i])) 
                          (third inputNote.[i])
                  yield tmp
          ]
          let normalWave = List.concat listNormalWave
          normalWave
  ```

  This function takes the list of notes as input and the sampleRate (usually 44100. wich is DVD rate)

  It output a list of float using the WaveGen.calcSin function to generate Sine waves from notes


  #### Filters

    Filters are here to add some modifications on the wave.

  ##### Amplitude

    
      let amplitude (initialList:list<float>) (amp:float) =
          let returnList = List.map (fun x -> x*amp) initialList
          returnList
    
    
    
This function take a representation of a wave as a list of Float and a multiplier as a Float.
It output a list of float after being changed by the multiplier.

It just multiply all value of the list by the multiplier, It can reduce values if multiplier is lower than 1, and higher value when the multiplier is higher than 1.
Be carefull to not make value go over 1 after the multiply, other the wave outputed will be totally different than expected.


  ##### Overdriven
  ##### Echo
  ##### Reverb
  ##### Flange



  #### Save

    save.write stream Wave = 

This is the way of calling the function to save a file.
  - stream is the parameter with the file name, it's an object ( See below )
  - Wave is the list offloat who have been fully proceed with various filters

    ``` let stream = File.Create(@"test.wav") ```
This is the way of declaring the stream parameter seen above. 
The name of the file is define as a string.


  #### Play

They are two ways to play a wave. 
    The first one is to save the sound before playing it.
    ```
    let playSound (name:string,save:bool,time:float32) =
    ```
    The first argument is a string as the name of the file
    The second is a bool as the save
    And the third one is a float32 as the starting time
      You can start the sound at where you want by changing the arguments of time.

The second way to play a wave is to save it, play it and then delete it.
    This way is here to not use too much local storage.
    To play this way, it's like the first way but you define save as false.


